package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.73

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	"github.com/Adityadangi14/solh_ai/chat"
	"github.com/Adityadangi14/solh_ai/db"
	"github.com/Adityadangi14/solh_ai/graph/model"
)

// GetResposne is the resolver for the getResposne field.
func (r *mutationResolver) GetResposne(ctx context.Context, input model.QueryInput) (*model.QueryResponse, error) {
	res, err := chat.SendPrompt(context.Background(), input.Query, input.UserID)

	if err != nil {
		return nil, err
	}

	return &model.QueryResponse{Response: res}, nil
}

// DeleteAllChat is the resolver for the deleteAllChat field.
func (r *mutationResolver) DeleteAllChat(ctx context.Context) (*model.DeleteAllChatResponse, error) {
	err := db.DeleteAllChat()

	if err != nil {
		return &model.DeleteAllChatResponse{Success: false, Message: err.Error()}, err
	}

	return &model.DeleteAllChatResponse{
			Success: true,
			Message: "Sueccessfully Deleted All Chats",
		},
		nil
}

// ChatsByUserID is the resolver for the chatsByUserId field.
func (r *queryResolver) ChatsByUserID(ctx context.Context, userID string) ([]*model.Chat, error) {
	res, _ := db.ReadChatsByUserId(userID)
	type ChatResponse struct {
		Get struct {
			Chat []struct {
				Answer    string    `json:"answer"`
				Query     string    `json:"query"`
				Timestamp time.Time `json:"timestamp"`
				UserID    string    `json:"userID"`
			} `json:"Chat"`
		} `json:"Get"`
	}

	var resp ChatResponse
	result, err := json.Marshal(res.Data)
	if err != nil {
		fmt.Println("Failed to marshal data:", err)
		return nil, err
	}

	fmt.Println(string(result))
	if err := json.Unmarshal(result, &resp); err != nil {
		fmt.Println("Failed to unmarshal data:", err)
		return nil, err
	}

	var chats []*model.Chat
	for _, item := range resp.Get.Chat {
		chats = append(chats, &model.Chat{
			Query:     item.Query,
			Answer:    item.Answer,
			UserID:    item.UserID,
			Timestamp: item.Timestamp.String(),
		})
	}

	return chats, nil
}

func (r *queryResolver) GetAllChat(ctx context.Context) ([]*model.Chat, error) {
	res, err := db.GetPreviousChat()
	if err != nil {
		return nil, err
	}

	type ChatResponse struct {
		Get struct {
			Chat []struct {
				Answer    string    `json:"answer"`
				Query     string    `json:"query"`
				Timestamp time.Time `json:"timestamp"`
				UserID    string    `json:"userID"`
			} `json:"Chat"`
		} `json:"Get"`
	}

	var resp ChatResponse
	result, err := json.Marshal(res.Data)
	if err != nil {
		fmt.Println("Failed to marshal data:", err)
		return nil, err
	}

	fmt.Println(string(result))
	if err := json.Unmarshal(result, &resp); err != nil {
		fmt.Println("Failed to unmarshal data:", err)
		return nil, err
	}

	var chats []*model.Chat
	for _, item := range resp.Get.Chat {
		chats = append(chats, &model.Chat{
			Query:     item.Query,
			Answer:    item.Answer,
			UserID:    item.UserID,
			Timestamp: item.Timestamp.String(),
		})
	}

	return chats, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
