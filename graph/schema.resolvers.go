package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.73

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	"github.com/Adityadangi14/solh_ai/appmodels"
	"github.com/Adityadangi14/solh_ai/chat"
	"github.com/Adityadangi14/solh_ai/constants"
	"github.com/Adityadangi14/solh_ai/db"
	"github.com/Adityadangi14/solh_ai/graph/model"
	"github.com/Adityadangi14/solh_ai/prompt"
	"github.com/weaviate/weaviate/entities/models"
)

// GetResposne is the resolver for the getResposne field.
func (r *mutationResolver) GetResposne(ctx context.Context, input model.QueryInput) (*model.QueryResponse, error) {
	res, err := chat.SendPrompt(context.Background(), input.Query, input.UserID)

	if err != nil {
		return nil, err
	}
	obj := appmodels.Chat{Query: input.Query, Answer: string(res), UserID: input.UserID, Timestamp: time.Now().Format(time.RFC3339)}
	chat.SaveChatData(obj.Map())

	return &model.QueryResponse{Response: res}, nil
}

// DeleteAllChat is the resolver for the deleteAllChat field.
func (r *mutationResolver) DeleteAllChat(ctx context.Context) (*model.DeleteAllChatResponse, error) {
	err := db.DeleteAllChat()

	if err != nil {
		return &model.DeleteAllChatResponse{Success: false, Message: err.Error()}, err
	}

	return &model.DeleteAllChatResponse{
			Success: true,
			Message: "Sueccessfully Deleted All Chats",
		},
		nil
}

// SendInitialMessage is the resolver for the sendInitialMessage field.
func (r *mutationResolver) SendInitialMessage(ctx context.Context, input model.InitialMessageInput) (*model.QueryResponse, error) {
	prompt := fmt.Sprintf("%v %v", prompt.InitPrompt, prompt.AnsweringGuidlines)
	res, err := chat.SendPrompt(context.Background(), prompt, input.UserID)

	if err != nil {
		return nil, err
	}

	response := &model.QueryResponse{Response: res}

	obj := appmodels.Chat{Query: "", Answer: string(res), UserID: input.UserID, Timestamp: time.Now().Format(time.RFC3339)}

	chat.SaveChatData(obj.Map())

	return response, nil
}

// DeleteChatForUser is the resolver for the deleteChatForUser field.
func (r *mutationResolver) DeleteChatForUser(ctx context.Context, input model.InitialMessageInput) (*model.DeleteAllChatResponse, error) {
	err := db.DeleteChatByUserId(input.UserID)

	if err != nil {
		return nil, err
	}
	return &model.DeleteAllChatResponse{
		Success: true,
		Message: "user chat deleted successfully",
	}, nil
}

// SaveContentData is the resolver for the saveContentData field.
func (r *mutationResolver) SaveContentData(ctx context.Context, input []*model.ContentInput) (*model.SuccessEvent, error) {
	var inp []*models.Object

	for _, item := range input {

		mod := appmodels.Content{
			Title:       item.Title,
			Description: item.Description,
			Url:         item.URL,
			Image:       item.Image,
			ContentType: item.Type,
		}
		in := &models.Object{
			Class:      constants.ClassContent.String(),
			Properties: mod.Map(),
		}

		inp = append(inp, in)

	}

	_, err := db.SaveContent(inp)

	if err != nil {
		return nil, err
	}

	return &model.SuccessEvent{Success: true, Message: "data successfully added"}, nil
}

// ChatsByUserID is the resolver for the chatsByUserId field.
func (r *queryResolver) ChatsByUserID(ctx context.Context, userID string) ([]*model.Chat, error) {
	res, _ := db.ReadChatsByUserId(userID)
	type ChatResponse struct {
		Get struct {
			Chat []struct {
				Answer    string    `json:"answer"`
				Query     string    `json:"query"`
				Timestamp time.Time `json:"timestamp"`
				UserID    string    `json:"userID"`
			} `json:"Chat"`
		} `json:"Get"`
	}

	var resp ChatResponse
	result, err := json.Marshal(res.Data)
	if err != nil {
		fmt.Println("Failed to marshal data:", err)
		return nil, err
	}

	if err := json.Unmarshal(result, &resp); err != nil {
		fmt.Println("Failed to unmarshal data:", err)
		return nil, err
	}

	var chats []*model.Chat
	for _, item := range resp.Get.Chat {
		chats = append(chats, &model.Chat{
			Query:     item.Query,
			Answer:    item.Answer,
			UserID:    item.UserID,
			Timestamp: item.Timestamp.String(),
		})
	}

	return chats, nil
}

// GetAllChat is the resolver for the getAllChat field.
func (r *queryResolver) GetAllChat(ctx context.Context) ([]*model.Chat, error) {
	res, err := db.GetPreviousChat()
	if err != nil {
		return nil, err
	}

	type ChatResponse struct {
		Get struct {
			Chat []struct {
				Answer    string    `json:"answer"`
				Query     string    `json:"query"`
				Timestamp time.Time `json:"timestamp"`
				UserID    string    `json:"userID"`
			} `json:"Chat"`
		} `json:"Get"`
	}

	var resp ChatResponse
	result, err := json.Marshal(res.Data)
	if err != nil {
		fmt.Println("Failed to marshal data:", err)
		return nil, err
	}

	if err := json.Unmarshal(result, &resp); err != nil {
		fmt.Println("Failed to unmarshal data:", err)
		return nil, err
	}

	var chats []*model.Chat
	for _, item := range resp.Get.Chat {
		chats = append(chats, &model.Chat{
			Query:     item.Query,
			Answer:    item.Answer,
			UserID:    item.UserID,
			Timestamp: item.Timestamp.String(),
		})
	}

	return chats, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
